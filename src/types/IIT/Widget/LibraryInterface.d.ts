import type { ConstantsInterface } from "@/types/IIT/Widget/ConstantsInterface";
import type { CertificateType } from "@/types/IIT/Widget/CertificateType";

declare namespace EndUser {
  interface Instance extends ConstantsInterface {
    /**
     * Реєстрація обробника для отримання сповіщення про події від віджету підпису
     */
    AddEventListener(
      /**
       * Тип події
       */
      eventType: number,

      /**
       * Функція-обробник подій
       */
      listener: (eventType: any) => void
    ): Promise<void>;

    /**
     * Зчитування ос. ключа користувача. Функція повинна викликатися до
     * функцій які використовують ос. ключ, наприклад SignHash, SignData.
     * Проміс буде виконано, коли користувач зчитає ос. ключ.
     * Якщо ос. ключ вже зчитано проміс виконується відразу.
     */
    ReadPrivateKey(): Promise<CertificateType[]>;

    /**
     * Стирання зчитаного ос. ключа користувача
     */
    ResetPrivateKey(): Promise<void>;

    /**
     * Формування нового сертифікату для діючого ключа. Діючий ключ попередньо
     * повинен бути зчитаний функцією ReadPrivateKey, після чого необхідно викликати
     * функцію MakeNewCertificate для відображена форми обрання носія нового ключа
     */
    MakeNewCertificate(
      /**
       * Інформація про користувача, яку необхідно змінити
       * в новому сертифікаті. Доступні поля phone, EMail. Опціональний параметр
       */
      euParams?: Record<any, any>
    ): Promise<void>;

    /**
     * Формування сертифікатів для пристрою з використанням ос. ключа
     * відповідальної особи. Ос. ключ відповідальної особи попередньо повинен
     * бути зчитаний функцією ReadPrivateKey, після чого необхідно викликати
     * функцію MakeDeviceCertificate для відображена форми формування сертифікатів
     */
    MakeDeviceCertificate(
      /**
       * Параметри сертифікату
       */
      certParams: Record<any, any>
    ): Promise<void>;

    /**
     * Зміна статусу сертифікату діючого ос. ключа користувача. Діючий ключ попередньо
     * повинен бути зчитаний функцією ReadPrivateKey, після чого необхідно викликати
     * функцію ChangeOwnCertificatesStatus
     */
    ChangeOwnCertificatesStatus(
      /**
       * Тип запиту для зміни статусу власного
       * сертифіката користувача
       */
      ccsType: number,

      /**
       * Причина відкликання власного сертифіката користувача.
       * При блокуванні сертифікату передається значення
       * EndUser.RevocationReason.Unknown
       */
      revocationReason: number
    ): Promise<void>;

    /**
     * Підпис геш значення
     * Повертається підпис
     */
    SignHash(
      /**
       * Геш значення для підпису у вигляді масиву
       * байт чи закодоване у вигляді строки BASE64
       */
      hash: Uint8Array | string | Array<Uint8Array | string>,

      /**
       * Признак необхідності повертати
       * підпис у вигляді строки BASE64. Опціональний параметр. За замовчанням - false.
       */
      asBase64String: boolean,

      /**
       * Алгоритм підпису. Можливі значення визначені в
       * EndUser.SignAlgo. За замовчанням - EndUser.SignAlgo.DSTU4145WithGOST34311.
       */
      signAlgo: number,

      /**
       * Тип підпису. Можливі значення визначені в
       * EndUser.SignType. За замовчанням - EndUser.SignType.CAdES_BES.
       */
      signType: number,

      /**
       * Попередній підпис для геш значення,
       * до якого буде додано створений підпис. Додавання підпису можливе лише за умови
       * якщо алгоритми підписів (signAlgo) співпадають, та попередній підпис
       * не містить підписувача. Опціональний параметр. За замовчанням - null.
       */
      previousSign?: Uint8Array | string | Array<Uint8Array | string> | null
    ): Promise<Uint8Array | string | Array<Uint8Array | string>>;

    /**
     * Підпис даних
     * Повертається підпис
     */
    SignData(
      /**
       * Дані для підпису. Дані, що передаються
       * у вигляді string автоматично конвертуються до типу Uint8Array з використанням
       * кодування UTF-8
       */
      data: Uint8Array | string | Array<Uint8Array | string>,

      /**
       * Признак необхідності формування зовнішнього
       * підпису (дані та підпис зберігаються окремо). Опціональний параметр.
       * За замовчанням - true.
       */
      external: boolean,

      /**
       * Признак необхідності повертати
       * підпис у вигляді строки BASE64. Опціональний параметр. За замовчанням - false.
       */
      asBase64String: boolean,

      /**
       * Алгоритм підпису. Можливі значення визначені в
       * EndUser.SignAlgo. За замовчанням - EndUser.SignAlgo.DSTU4145WithGOST34311.
       */
      signAlgo: number,

      /**
       * Попередній підпис для даних,
       * до якого буде додано створений підпис. Додавання підпису можливе лише за умови
       * якщо алгоритми підписів (signAlgo) співпадають, та попередній підпис
       * не містить підписувача. Опціональний параметр. За замовчанням - null.
       * Для внутрішнього підпису (external = false) параметр data не використовується.
       */
      previousSign?: Uint8Array | string | Array<Uint8Array | string> | null,

      /**
       * Тип підпису. Можливі значення визначені в
       * EndUser.SignType. За замовчанням - EndUser.SignType.CAdES_BES.
       */
      signType?: number
    ): Promise<Uint8Array | string | Array<Uint8Array | string>>;

    /**
     * Зашифрування даних з використанням алгоритму ГОСТ 28147-2009 та
     * протоколу розподілу ключів ДСТУ 4145-2002. Зчитаний ос. ключ повинен мати
     * сертифікат, який призначений для протоколів розподілу ключів в державних
     * алгоритмах та протоколах.
     *
     * Повертаються зашифровані дані
     */
    EnvelopData(
      /**
       * Сертифікати отримувачів.
       * Сертифікати отримувачів повинні мати призначеня для протоколів розподілу
       * ключів в державних алогритмах та протоколах.
       */
      recipientsCerts: Uint8Array[],

      /**
       * Дані для зашифрування. Дані, що
       * передаються у вигляді string автоматично конвертуються до типу Uint8Array
       * з використанням кодування UTF-8
       */
      data: Uint8Array | string,

      /**
       * Признак необхідності додатково підписувати дані
       * (зашифровані дані спеціального формату з підписом, який автоматично
       * перевіряється при розшифруванні даних). Зчитаний ос. ключ повинен мати
       * сертифікат, який призначений для підпису даних за алгоритмом ДСТУ 4145.
       * Опціональний параметр. За замовчанням - false.
       */
      signData: boolean,

      /**
       * Признак необхідності повертати
       * зашифровані дані у вигляді строки BASE64. Опціональний параметр.
       * За замовчанням - false.
       */
      asBase64String: boolean,

      /**
       * Признак необхідності зашифровувати дані з
       * використанням динамічного ключа відправника. Призначений для використання у
       * разі відсутності сертифікат відправника, який призначений для протоколів
       * розподілу ключів в державних алгоритмах та протоколах. Опціональний параметр.
       * За замовчанням - false.
       */
      useDynamicKey: boolean
    ): Promise<Uint8Array | string>;

    /**
     * Розшифрування даних з використанням алгоритму ГОСТ 28147-2009 та
     * протоколу розподілу ключів ДСТУ 4145-2002. Зчитаний ос. ключ повинен мати
     * сертифікат, який призначений для протоколів розподілу ключів в державних
     * алгоритмах та протоколах.
     *
     * Повертається інформація про відправника та розшифровані дані
     */
    DevelopData(
      /**
       * Дані для розшифрування. Дані, що
       * передаються у вигляді string повинні бути закодовані з використанням кодування
       * BASE64
       */
      envelopedData: Uint8Array | string,

      /**
       * Сертифікат відправника зашифрованих даних.
       * Опціональний параметр. За замовчанням - null.
       */
      senderCert: Uint8Array
    ): Promise<any>; // todo describe
  }
}
